# 技术演变

## 技术变革

{% tabs %}
{% tab title="变革趋势" %}
<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption><p>来源于 redhat在2015年的openshift的容器大会上的一张PPT，这张图在当时给出了几个技术领域的发展趋势，目前来看，基本上都实现了。</p></figcaption></figure>


{% endtab %}

{% tab title="2. 研发框架" %}
<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption><p>经过一代代的研发模式的演进，目前微服务架构(Microservice Architecture)作为一种更为灵活的架构思想，在业界逐渐流行起来，这种架构相较于其他几种架构来说，更加需要从整体上对软件系统进行通盘的考虑。</p></figcaption></figure>

{% hint style="info" %}
微服务架构旨在通过将功能分解到各个离散的服务中，在架构系统层次以实现对解决方案的解耦，并提供更加灵活的服务支持。它围绕业务领域，将一个大型的单个应用程序和服务拆分为数个甚至数十个的小规模应用服务，通过扩展单个组件数量，加强小组件应用之间的协调，用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题，同时满足服务等级要求。

> 概念起源：http://martinfowler.com/articles/microservices.html
{% endhint %}

微服务架构对基础设施要求比较高，在实践的过程中，严重依赖<mark style="color:green;">**持续集成、服务注册、服务发现、负载均衡、监控检测、配置管理、服务路由、服务容错、日志收集、指标收集、调用链追踪**</mark>等，而构建这一套基础设施的成本是非常巨大的，所以微服务相关的框架就应运而生。
{% endtab %}

{% tab title="3. 微服务的几个要点和引入问题" %}
<mark style="color:green;">**要点**</mark>

1. 大的单体应用拆分为很多小的模块
2. 小模块之间定义清晰接口，规约其与其他接口通信&#x20;
3. 微服务之间相互独立，每个微服务可以单独部署、升级、回滚等&#x20;
4. 每个微服务可以由1或几人组成的小团队负责其整个生命周期（开发、测试、部署与运维等）

<mark style="color:orange;">**问题**</mark>&#x20;

\----最核心的点&#x20;

• 微服务间如何相互服务发现（Visibility）&#x20;

• 如何管控微服务间的流量（Traffic Control），说白了就是负载均衡&#x20;

\----其他的关注点&#x20;

• 微服务的弹性能力和效率（Resiliency & Effiency）&#x20;

• 如何保证微服务通信安全（Security）&#x20;

• 如何实施控制策略（Policy Enforcement） 一般来说，作为一个架构师，我们把前面两个最核心的点搞清楚了，其他的就很简单了。
{% endtab %}
{% endtabs %}

## 实践方法

> 微服务项目的困难点--<mark style="color:red;">**通信**</mark>

{% hint style="warning" %}
问题

<mark style="color:purple;">**传统的Monolithic方式开发的项目**</mark>

所有的子应用服务都是直接在本地的，所以对于传统的web项目来说，客户端的访问非常简单，直接通过UI界面的地址直接调用即可。

<mark style="color:purple;">**微服务项目的开发**</mark>

所有的功能拆分成无数个独立的服务，而且在独立的应用环境中开发/部署/更新，从而实现业务项目的快速迭代更新，所以服务间的通信质量就是一个非常繁琐的任务。
{% endhint %}

{% hint style="success" %}
解决办法

服务访问：为了实现服务间的高效通信，在微服务架构中，将服务的管理单独剥离开，形成一个单独的网关系统(API Gateway),它的主要特点是：&#x20;

1 对外：提供统一服务入口，让微服务对客户端透明;&#x20;

2 对内：聚合子应用服务,提升性能,提供安全|过滤|流控等API管理功能。
{% endhint %}

**内部通信:** 针对业务应用拆分后的所有微服务都是独立部署在专用环境上，服务间的采用IPC方式通信，而且市面上有很多成熟的方案。目前最通用的方式主要有以下几种：&#x20;

1. 同步方式调用：REST(http数据格式)、RPC(自有数据格式)；&#x20;
2. 异步方式调用：借助消息队列的方式来降低服务间耦合，也缓冲服务间调用，常见方案Kafka, Notify,等&#x20;

**服务实现**: 在微服务架构中，每个服务都可能有多个随时变动的副本实例以负载均衡的方式提供服务，对于这种场景，他们一般以服务发现的机制来对服务进行统一管理，子应用服务上线时，服务提供者将自己的服务信息注册到registry，并通过心跳维持长链接，实时更新链接信息(包括服务下线)

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

### 设计模式

对于微服务项目来说，它为了实现大规模服务之间的稳定通信功能，在设计模式上也下足了很多功夫

{% tabs %}
{% tab title="聚合模式" %}
<figure><img src="../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

这是最简单的一种微服务设计模式，聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的Web页面，将检索到的数据进行处理展示。

> 代理模式是聚合模式的一个变种，在这种情况下，客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作。这种模式是目前微服务管理的最常见的一种模式。
{% endtab %}

{% tab title="链式模式" %}
<figure><img src="../../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

是在服务调用场景下存在的一种模式，服务A接收到请求后会与服务B进行通信，类似地，服务B会同服务C进行通信。所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。因此，服务调用链不宜过长，以免客户端长时间等待。 分支模式是聚合器模式的扩展，允许同时调用两个微服务链，
{% endtab %}
{% endtabs %}

## 服务基础的演变

{% tabs %}
{% tab title="1. 单体式服务间通信" %}
<figure><img src="../../.gitbook/assets/image (5) (1).png" alt=""><figcaption><p><strong>集中式代理服务模式:</strong> 以nginx或者LVS为例，我们在nginx中定制两个后端服务，然后通过upstream实现负载均衡。存在单点问题的。</p></figcaption></figure>
{% endtab %}

{% tab title="2. 分层式服务阶段" %}
<figure><img src="../../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

**左图**：在复杂的服务通信过程中，涉及到了业务逻辑和服务网络控制相关的内容，所以直接在代码中，通过繁杂的代码功能实现各自的功能。&#x20;

**右图**：互联网的基础网络技术发展很快，TCP/IP 这类标准的出现解决了流量控制等问题，我们可以将服务网络控制的逻辑流程从代码中抽取出来，整合为操作系统网络层的一部分。

{% hint style="info" %}
嵌入式代理服务模式： 以Eureka为例，他们有服务端，然后有很多Client。假如A-Client要访问B-Client，在A-Client端存在一些EurekaClient.jar包，它从server端的服务注册表中获B-Client的地址信息，然后直接向B-Client发起请求。 Nacos、Dubbo也是相似的流程。<mark style="color:red;">**存在代码侵入、语言绑定、重复代码功能**</mark>等问题
{% endhint %}
{% endtab %}

{% tab title="3. 分布式服务阶段" %}
<figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

**左图**：随着可靠性服务的规模越来越大，服务节点越来越多，当我们的架构发展已经超越了基础网络的发展，服务通信部分的功能，只能由程序员通过代码的方式在内部来实现。&#x20;

**中图**：技术能力强的公司，将服务通信部分的功能实现整合为了一系列的专有框架，我们可以直接套用这类框架来快速的实现相应的功能，但框架代码对我们的项目代码的侵入性很强，而且受到了框架语言的限制，而且这部分的软件维护是很困难的。&#x20;

**右图**：与网络协议栈一样，所以程序员采用了一种代理的方式，将该功能从业务逻辑和底层网络基础设施中独立出来，专门形成了一套以服务治理为中心的服务网络管理方案。

{% hint style="info" %}
**主机独立进程代理：** 以A服务访问B服务为例，A|B服务部署的时候，内部有一个独立的进程proxy，它会主动向“服务注册中心”注册自己的基本信息，A服务访问B服务的时候，由内部的proxy进程向服务注册中心发起请求，获取B服务的地址信息，然后A服务的proxy再向B服务的proxy进程发起请求。 这种模式，将大量服务相关的功能，沉淀到基础设施层面，实现基础设施功能库的随意调用。
{% endhint %}
{% endtab %}
{% endtabs %}

## 服务网格的演变

微服务在发展的过程中，遇到了各种各样的问题，也有了各种各样的解决方案，尤其是微服务框架的出现让微服务的发展快速起来，但是随着框架而来的，就是各种各样的限制： 框架语言的限制、 项目代码的入侵、 基础设施标准化等。 所以人们开始想方法，将微服务的项目代码开发和服务间的通信剥离开，所以服务网格(Service Mesh)就出现了。&#x20;

其实服务网格并没有什么新的概念和功能，它只是把原来服务框架所做的功能完全独立出来，整合了一个服务网格的基础设施层，实现了服务和服务治理功能完全解耦，所以服务网格的概念已经提出，便得到了很多人的支持，希望能够解决当前微服务所遇到的问题。

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

初级阶段的网格

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

直接在sidecar内部通过手工或者模板的方式定制大量流量相关的策略配置，但是这种方式虽然能够实现一定意义层面的服务治理作用，但是在大规模场景中，这些繁琐的配置文件定制是一个非常困难的点。 所以在服务网格的初级阶段的后期，我们最期望的是有一个控制服务，专门用于定制各种流量策略相关的配置信息。
