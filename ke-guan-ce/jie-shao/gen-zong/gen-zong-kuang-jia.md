# 跟踪框架



{% tabs %}
{% tab title="OpenTracing" %}
* 中立的（厂商无关、平台无关）分布式追踪的API规范，提供统一接口，方便开发者在自己的服务中集成一种或多种分布式的追踪的实现
* OpenTracing自身的是一个Library，它定义了一套通用的数据上报接口，各个分布式追踪系统都可以实现这套接口，应用程序只需要对接OpenTracing,而无需关心后端采用的到底什么分布式追踪系统
* 于2016年10月加入CNCF基金会

<mark style="color:red;">**缺点**</mark>：**对于如何跟踪关系还缺乏标准**

OpenTracing 是一个开源的分布式跟踪规范，旨在提供一套标准化的API，用于分布式系统中的跟踪数据收集和传播。通过OpenTracing，开发者可以在不同的追踪系统之间切换，而无需修改应用程序代码。




{% endtab %}

{% tab title="OpenCensus" %}
* 由Google开源的一个用来收集和追踪应用指标的第三方库
* 提供了一套统一的测量工具:跨服务捕获跟踪Span、应用级别指标以及来自其他应用的元数据（例如日志）
* 它将自定义为更多的可观察性框架，而不仅仅是跟踪

OpenCensus 是一个用于分布式跟踪和度量收集的开源框架，旨在帮助开发者更好地监控和诊断其分布式应用程序。
{% endtab %}

{% tab title="OpenTelemetry" %}
为了统一分布式跟踪和度量收集的标准，OpenTracing和OpenCensus项目在2019年宣布合并，形成了**OpenTelemetry**。

OpenCensus和OpenTracing是两个用于分布式跟踪和度量收集的开源框架，它们之间有许多相似之处，但也有一些关键的不同点。以下是对它们相同和不同之处的详细介绍：

**相同点**

1. **分布式跟踪：**两者都支持分布式跟踪，能够跟踪跨多个服务的请求路径，帮助开发者了解和诊断系统中的性能问题和错误。
2. **多语言支持：**两者都支持多种编程语言，如Java、Go、Python、JavaScript等，方便在不同的技术栈中使用。
3. **社区驱动：**两者都是由开源社区驱动的发展项目，并得到了广泛的支持和使用。
4. **供应商中立：**两者都致力于供应商中立，允许开发者选择适合的后端系统进行数据存储和分析，而不受特定供应商的限制。

**不同点**

<table><thead><tr><th width="118"></th><th>OpenTracing</th><th>OpenCensus</th></tr></thead><tbody><tr><td><strong>功能范围</strong></td><td>主要专注于分布式跟踪，提供了标准化的API用于生成和管理Trace和Span。</td><td>不仅支持分布式跟踪，还包括度量收集功能，可以收集和报告系统的各种度量数据。</td></tr><tr><td><strong>架构设计</strong></td><td>是一个规范，提供了一套标准化的接口定义，具体的实现由各个追踪系统（如Jaeger、Zipkin等）提供。</td><td>是一个完整的框架，提供了追踪和度量收集的实现以及数据导出的组件，能够直接使用。</td></tr><tr><td><strong>自动化仪器</strong></td><td>主要依赖于手动在代码中插入追踪点，虽然也有一些自动化工具，但不如OpenCensus全面。</td><td>提供了更多的自动化仪器，能够自动收集常见库和框架（如HTTP、gRPC等）的追踪和度量数据。</td></tr><tr><td><strong>数据导出</strong></td><td>本身不包含数据导出功能，需要配合具体的追踪系统来实现数据导出。</td><td>提供了内置的导出器，可以将数据导出到多种后端系统（如Prometheus、Zipkin、Jaeger、Stackdriver等）。</td></tr></tbody></table>

OpenTelemetry结合了两者的优点，提供了一套统一的API和SDK，用于分布式跟踪和度量收集。以下是OpenTelemetry的主要特点：

1. **统一API和SDK：**OpenTelemetry提供了统一的API和SDK，用于生成和收集分布式跟踪和度量数据。
2. **多语言支持：**支持多种编程语言，方便在不同的技术栈中使用。
3. **自动化仪器：**提供了丰富的自动化仪器，能够自动收集常见库和框架的跟踪和度量数据。
4. **灵活的导出机制：**提供了灵活的导出机制，支持将数据导出到多种后端系统。
5. **社区驱动：**由开源社区驱动的发展项目，得到了广泛的支持和使用。

OpenTelemetry是由OC和OT合并生成一个新项目



<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1).png" alt=""><figcaption><p>这张图片展示了OpenTelemetry的架构，包括API、SDK和Collector的工作流程。以下是对图片内容的详细介绍，帮助你更好地理解OpenTelemetry的工作原理。</p></figcaption></figure>

<details>

<summary><strong>OpenTelemetry API</strong></summary>

图片最上方展示了OpenTelemetry API，主要包括以下部分：

1. **Semantic Conventions（语义约定）：**规范了各种跟踪和度量数据的标准化标签和属性，以确保数据的一致性和可理解性。
2. **Tracer API：**用于生成和管理Trace和Span，帮助跟踪请求的生命周期。
3. **Context API：**用于在不同的服务和组件之间传递上下文信息，确保跟踪数据的一致性。
4. **Meter API：**用于收集和报告度量数据，帮助监控系统的性能和健康状况。

</details>

<details>

<summary><strong>OpenTelemetry SDK</strong></summary>

中间部分展示了OpenTelemetry SDK的组件：

1. **Tracer：**核心组件，用于创建和管理Span。
2. **Span Processor：**处理生成的Span数据，可以进行过滤、采样和批处理等操作。
3. **Span Exporter：**将处理后的Span数据导出到指定的后端系统（如Zipkin、Jaeger等）。
4. **Shared Context：**共享上下文，用于在不同的服务和组件之间传递追踪信息。
5. **Propagator：**负责上下文的传播，确保请求在不同的服务之间能够携带完整的追踪信息。
6. **Meter：**核心组件，用于创建和管理度量数据。
7. **Instrument：**定义具体的度量指标，如计数器、直方图等。
8. **Aggregator：**聚合度量数据，进行统计计算，如平均值、百分位数等。
9. **MetricReader：**读取度量数据，准备导出。
10. **Metric Exporter：**将处理后的度量数据导出到指定的后端系统（如Prometheus等）。

</details>

<details>

<summary><strong>OpenTelemetry Collector</strong></summary>

底部展示了OpenTelemetry Collector的角色：

1. **Collector**
   * 一个独立的服务，负责接收、处理和导出来自多个来源的跟踪和度量数据。
   * 可以部署在不同的位置，如本地、云端等，作为集中式的数据收集和处理中心。
2. **Span Exporter：**从SDK接收Span数据，并将其导出到后端系统。
3. **Metric Exporter：**从SDK接收度量数据，并将其导出到后端系统。

</details>

**工作流程总结**

1. **数据生成：**应用程序通过OpenTelemetry API生成跟踪和度量数据。
2. **数据处理：**OpenTelemetry SDK处理这些数据，包括上下文传播、数据聚合等。
3. **数据导出：**处理后的数据通过Exporters导出到指定的后端系统。
4. **数据收集：**OpenTelemetry Collector作为中间层，集中收集和处理来自多个来源的数据，并导出到最终的存储或分析系统。

上图展示了OpenTelemetry如何通过API和SDK生成、处理和导出跟踪和度量数据，并通过Collector集中管理这些数据。通过这套架构，开发者可以方便地监控和诊断分布式系统的性能和健康状况。
{% endtab %}

{% tab title="Zipkin" %}
由Twitter基于Dapper论文实现的开源分布式追踪系统，通过收集分布式服务执行时间的信息来达到追踪服务调用链路、以及分析服务执行延迟等目的。

架构组件

* collector：信息收集器守护进程
* storage：存储组件
* API：search API查询进程
* web UI: 用户界面

Zipkin 是一个开源的分布式追踪系统，用于收集和分析跨多个微服务的请求数据。它帮助开发者理解请求在系统中的流动情况，识别性能瓶颈和错误。下面是对Zipkin的通俗易懂的详细介绍：



**Zipkin的核心概念**

1. **Trace（跟踪）**
   * 一个Trace代表一个请求的整个生命周期，从开始到结束。它由多个Span组成，每个Span代表Trace中的一个操作。
2. **Span（跨度）**
   * Span是Trace中的一个单独操作，记录了操作的开始时间、结束时间、持续时间、操作名称和其他元数据（如标签和日志）。
3. **Annotations（注解）和 Tags（标签）**
   * 注解：记录了特定时间点发生的事件，比如服务器接收到请求或发送响应。
   * 标签：用于记录关键值对，比如HTTP方法、状态码等。

**Zipkin架构**

1. **Instrumentation（仪器化）：**在你的应用代码中加入追踪代码，以便生成和收集Trace和Span数据。这一步通常通过Zipkin提供的客户端库完成，这些库支持多种编程语言（如Java、Go、Python等）。
2. **Collector（收集器）：**收集器接收来自应用程序的追踪数据，可以通过多种方式（如HTTP、Kafka等）发送数据到收集器。收集器将这些数据存储在数据库中（如MySQL、Elasticsearch等）。
3. **Storage（存储）：**Zipkin存储组件负责将收集到的追踪数据存储在持久化存储中，以便后续查询和分析。
4. **Query（查询）：**查询组件提供了一个API接口，允许用户查询和获取存储的追踪数据。通常，这个接口会被Zipkin的前端UI使用。
5. **UI（用户界面）：**Zipkin提供了一个Web界面，用户可以通过这个界面可视化和分析追踪数据，查看请求的详细信息和整个请求路径中的各个操作。

**Zipkin的工作流程**

1. **数据生成：**当一个请求进入应用程序时，应用程序的追踪代码生成一个Trace，并为Trace中的每个操作生成一个Span。
2. **数据收集：**生成的Trace和Span数据通过HTTP或其他传输方式发送到Zipkin的收集器。
3. **数据存储：**收集器接收到数据后，将其存储在配置好的数据库中。
4. **数据查询：**用户可以通过Zipkin的查询API请求特定的Trace数据。
5. **数据展示：**查询到的Trace数据通过Zipkin的Web界面展示出来，用户可以查看请求的详细信息和路径。

**使用Zipkin的好处**

1. **可视化请求路径：**Zipkin帮助你可视化每个请求在系统中的流动路径，了解每个操作的耗时情况。
2. **识别性能瓶颈：**通过查看每个操作的持续时间，你可以识别出性能瓶颈，找到导致请求延迟的原因。
3. **调试和故障排查：**Zipkin记录了请求的详细信息和错误日志，帮助你调试和排查系统中的问题。
4. **多语言支持：**Zipkin支持多种编程语言，方便在不同技术栈的系统中使用。

**示例场景**

假设你有一个电子商务网站，当用户下单时，系统需要调用多个微服务：用户服务、订单服务、支付服务和库存服务。使用Zipkin，你可以追踪整个下单过程，查看每个微服务的响应时间，识别出哪个服务可能导致了延迟。

**总结**

Zipkin通过分布式追踪帮助开发者了解和优化微服务架构中的请求流动情况，识别和解决性能瓶颈和错误，提供了强大的可视化和分析工具。通过简单的架构和多语言支持，Zipkin在分布式系统监控和诊断方面提供了极大的便利。

<figure><img src="../../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption><p>这张图片展示了Zipkin的工作流程和架构，通过追踪和记录请求在分布式系统中的流动情况来帮助开发者监控和诊断系统性能问题。</p></figcaption></figure>



* **Instrumented client（已添加追踪代码的客户端）：**这是一个已经集成了Zipkin追踪代码的客户端应用，它会生成和报告追踪数据（Trace和Span）。
* **Instrumented server（已添加追踪代码的服务器）：**这是一个已经集成了Zipkin追踪代码的服务器应用，它会接收客户端的请求，并生成和报告自己的追踪数据。
* **Non-instrumented server（未添加追踪代码的服务器）：**这是一个没有集成Zipkin追踪代码的服务器应用，它不会生成或报告追踪数据。
* **Transport（传输）：**追踪数据通过网络传输，从客户端和服务器发送到Zipkin的收集器。
* **Zipkin组件**
  * **Collector（收集器）**：接收并处理从客户端和服务器发送来的追踪数据。
  * **Storage（存储）**：将处理后的追踪数据存储在数据库中，以便后续查询和分析。
  * **API**：提供查询接口，允许用户通过API请求特定的追踪数据。
  * **UI（用户界面）**：提供一个Web界面，用户可以通过这个界面可视化和分析追踪数据。
* **Database（数据库）：**用于存储从Zipkin收集器接收到的追踪数据。

**通俗易懂的介绍**

想象一下你正在使用一个快递公司的系统来追踪你的包裹。从你下单开始，到包裹被分配到不同的运输站点，最后送达你的手中，这个过程类似于一个请求在分布式系统中的流动。Zipkin就像这个快递公司的追踪系统，记录了包裹（即请求）在每个站点的流转信息。

**详细步骤**

1. **生成追踪数据：**当你在一个集成了追踪代码（Instrumented）的客户端下单时，这个客户端会生成一个追踪记录（Trace），并记录下单这个操作（Span）。
2. **传递追踪数据：**下单请求会被发送到一个集成了追踪代码的服务器，这个服务器会继续记录处理请求的操作（Span），并将这些追踪数据通过网络传输到Zipkin的收集器。
3. **收集和存储数据**
   * Zipkin的收集器就像是快递公司的中央处理站，接收从各个客户端和服务器发送来的追踪数据。
   * 收集器将这些数据进行处理，并存储在一个数据库中。
4. **查询和可视化数据：**Zipkin提供了一个API接口和一个Web界面，类似于快递公司的在线追踪系统。你可以通过这个接口或界面查询你的包裹（请求）的流转情况，了解它在每个站点的详细信息。

**总结**

通过这个快递公司的比喻，你可以更容易地理解Zipkin的工作流程和架构。Zipkin帮助你追踪和记录请求在分布式系统中的流动情况，就像追踪包裹在快递系统中的路径一样，帮助你了解系统的性能和发现问题。
{% endtab %}

{% tab title="Jaeger" %}
Jaeger 是一个开源的端到端分布式追踪系统，最初由Uber Technologies开发，用于监控和排查微服务架构中的事务。Jaeger可以帮助开发者分析系统性能，发现瓶颈，优化服务调用。以下是对Jaeger的详细介绍：

**Jaeger的核心概念**

1. **Trace（跟踪）：**一个Trace表示一个事务或请求的整个生命周期。它由多个Span组成，每个Span代表Trace中的一个独立操作。
2. **Span（跨度）：**Span是Trace中的一个基本单元，包含了操作的开始时间、结束时间、持续时间、操作名称和相关的元数据（如标签和日志）。
3. **Tags（标签）：**键值对，用于记录Span的额外信息，如HTTP状态码、错误信息等。
4. **Logs（日志）：**记录特定事件的时间戳和详细信息，如错误信息、状态变更等。

**Jaeger的架构**

1. **Instrumentation（仪器化）：**在应用程序中集成Jaeger客户端库，通过追踪代码生成和报告Trace和Span数据。这一步通常通过Jaeger提供的客户端库完成，这些库支持多种编程语言（如Java、Go、Python等）。
2. **Jaeger Agents（代理）：**部署在每个主机上的网络守护进程，负责接收追踪数据并将其发送到集中式的Jaeger Collector。
3. **Jaeger Collectors（收集器）：**接收来自代理的追踪数据，进行验证和批处理，然后将数据存储到持久化存储中（如Elasticsearch、Cassandra等）。
4. **Jaeger Query（查询）：**提供一个查询API和Web用户界面，允许用户查询和可视化存储的追踪数据。
5. **Storage（存储）：**Jaeger支持多种持久化存储后端，如Elasticsearch、Cassandra、Kafka等，用于存储和检索追踪数据。

**Jaeger的主要功能**

1. **分布式上下文传播：**Jaeger能够在不同服务之间传播上下文信息，确保完整的追踪数据。
2. **高性能和可扩展性：**Jaeger设计用于处理高吞吐量的追踪数据，支持大规模的微服务架构。
3. **多语言支持：**Jaeger客户端库支持多种编程语言，方便在不同技术栈中使用。
4. **强大的查询和可视化能力：**Jaeger提供了一个功能强大的Web界面，用户可以通过它查询和可视化追踪数据，分析系统性能和发现瓶颈。

**Jaeger的工作流程**

1. **数据生成：**当一个请求进入应用程序时，集成了Jaeger客户端库的应用程序会生成一个Trace，并为Trace中的每个操作生成一个Span。
2. **数据收集：**生成的Trace和Span数据被发送到部署在主机上的Jaeger代理。
3. **数据处理：**Jaeger代理将追踪数据发送到Jaeger收集器，收集器对数据进行验证和批处理。
4. **数据存储：**处理后的追踪数据被存储在配置好的持久化存储后端中。
5. **数据查询：**用户可以通过Jaeger的查询API或Web界面查询特定的Trace数据。
6. **数据展示：**查询到的Trace数据通过Jaeger的Web界面展示出来，用户可以查看请求的详细信息和路径。

**使用Jaeger的好处**

1. **全面的请求追踪：**Jaeger帮助你全面追踪请求在系统中的路径，了解每个操作的详细信息和耗时情况。
2. **识别性能瓶颈：**通过分析每个操作的持续时间，Jaeger帮助你识别出系统中的性能瓶颈。
3. **调试和故障排查：**Jaeger记录了请求的详细信息和错误日志，帮助你调试和排查系统中的问题。
4. **支持大规模部署：**Jaeger设计用于高吞吐量和大规模微服务架构，支持高并发的追踪数据处理。

**示例场景**

假设你有一个电子商务网站，当用户下单时，系统需要调用多个微服务：用户服务、订单服务、支付服务和库存服务。使用Jaeger，你可以追踪整个下单过程，查看每个微服务的响应时间，识别出哪个服务可能导致了延迟。

<figure><img src="../../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption><p>这张图片展示了Jaeger的工作流程和架构，帮助我们理解如何使用Jaeger进行分布式追踪。为了更通俗易懂地介绍，我们可以将整个流程比作一个包裹物流系统。</p></figcaption></figure>

**具体组件和流程**

1. **Application（应用程序）：**你的业务代码，就像需要发货的商品。
2. **Jaeger Client（Jaeger客户端）：**集成在应用程序中的库，负责生成追踪数据（Trace和Span），就像商品的出库单。
3. **Jaeger Agent（Jaeger代理）：**部署在每个主机或容器上的守护进程，负责收集应用程序发送的追踪数据，就像每个仓库的快递员收集包裹。
4. **Transport（传输）：**通过UDP协议将追踪数据从Jaeger客户端发送到Jaeger代理，就像快递员将包裹从仓库送到物流中心。
5. **Jaeger Collector（Jaeger收集器）：**收集器接收从代理发送来的追踪数据，进行验证和批处理，然后存储在数据库中。它还有自适应采样（Adaptive Sampling）的功能，可以根据需要调整数据采样率，就像物流中心对包裹进行分类和整理。
6. **Database（数据库）：**存储所有收集到的追踪数据，就像物流中心的存储系统，保存所有包裹的信息。
7. **Spark Jobs：**用于数据处理和分析，帮助优化和管理追踪数据，就像物流系统中的自动化分拣和数据分析工具。
8. **Jaeger Query（Jaeger查询）：**提供查询接口，允许用户通过API请求特定的追踪数据，就像物流系统的查询接口，用户可以查找包裹的状态。
9. **UI（用户界面）：**提供一个Web界面，用户可以通过这个界面可视化和分析追踪数据，就像快递公司的在线追踪系统，用户可以查看包裹的运输路径和状态。

**流程总结**

1. **生成追踪数据：**当应用程序处理请求时，Jaeger客户端生成追踪数据，并通过UDP协议发送到Jaeger代理。
2. **收集和传输数据：**Jaeger代理接收到追踪数据后，将其推送到Jaeger收集器。
3. **数据处理和存储：**Jaeger收集器对数据进行验证和批处理，并将其存储在配置好的数据库中。
4. **数据查询和展示：**用户可以通过Jaeger的查询API或Web界面查询和可视化追踪数据，查看请求的详细信息和路径。

**通俗易懂的比喻**

想象一下，你在一个电子商务网站上购买了一件商品：

1. **应用程序** 就是这个电子商务网站，它处理你的订单。
2. **Jaeger客户端** 生成一张出库单，记录了商品的详细信息。
3. **Jaeger代理** 就像是仓库的快递员，收集所有出库单并准备发送到物流中心。
4. **传输过程** 就像快递员将包裹送到物流中心。
5. **Jaeger收集器** 在物流中心接收包裹，对它们进行分类和整理，然后存储在中心的数据库中。
6. **数据库** 存储了所有包裹的信息，方便后续查询。
7. **Spark Jobs** 进行数据处理和优化，帮助物流中心更高效地管理包裹。
8. **Jaeger查询和用户界面** 让你可以在线查询包裹的状态，查看包裹的运输路径和当前所在位置。

通过这个比喻，你可以更直观地理解Jaeger如何帮助开发者追踪和分析分布式系统中的请求流动情况，识别性能瓶颈和错误，从而优化系统性能。&#x20;
{% endtab %}
{% endtabs %}

